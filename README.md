# Polyomino-solver
Решение задачи точного замощения полимино заданным набором фигур. 

Спасибо Принципу Талоса и его прекрасным пазлам, в частности последнему желтому, за вдохновение к разработке. Лучи добра я разработчикам слал, и домашним животным их, и элохиму с ПБМ.

Программа переводит задачу полимино на язык Алгоритма Х. Для решения Алгоритма Х используется библиотека algorithm-x.

## Методичка
В общем виде пользование пакетом выглядит так:
1. Подключите пакет и numpy
```python
import numpy as np
from polyominator import polyomino
```
2. Задайте поле как массив, где 1 --- ячейка для замощения, 0 --- не для замощения (типа, булев массив). Например, прямоугольное поле 3х2 будет выглядеть так:
```python
area = np.array([
    [1,1,1],
    [1,1,1],
    [1,1,1]
])
```
3. Задайте фигуры как массивы, где 1 --- элемент фигуры, 0 --- свободное пространство (опять буллев массив). Например, вот 3-сегментный уголок, 2-сегментная палка и одиночный сегмент, соответственно:
```python
corner = np.array([
    [1,1],
    [1,0],
])
stick = np.array([
    [1,1]
])
ceil = np.array([
    [1]
])
```
Обратите внимание, что нет какого то фиксированного размера массива для фигур. Главное чтоб фигура помещалась в массив.

4. Передайте поле и список фигур в класс `polyomino`.
```python
figures = [corner,corner,stick,ceil]
pm = polyomino(figures=figures,area=area)
```
5. Получите единственное решение (аргумент метода `get_only_one_solve = True`) или генератор всех решений (`get_only_one_solve = False`) использовав метод `solve`. По умолчанию `get_only_one_solve = True`.
```python
solution = pm.solve()
#solutions_generator = pm.solve(False)

>>> [[0 0 2]
>>>  [0 1 2]
>>>  [3 1 1]]
```

### Как выглядит решение
Решение, которое (или которые) вам вернет программа, выглядят как массив, размерностью совпадающий с полем, и заполненый числами. Если вам кажется, что эти числа образуют фигуры, вам не кажется. При передачи фигур в класс, они нуммеруются в порядке передачи (с 0). В данном случае:
- 0: corner,
- 1: corner,
- 2: stick,
- 3: ceil.

И из этих цифр формируется силуэт фигуры в том месте поля в который эту фигуру надо сунуть.

## Пример
Даны поле и фигуры для замощения:

![Рис.1. Поле для замощения](/img/Screenshot_6.png)
![Рис.2. Фигуры для замощения](/img/Screenshot_7.png)

Тогда поиск верного замощения представлен в файле `examples\get_one_solve_2.py`.
Вывод выглядит так:
```
[[0 1 1 1] 
 [0 0 1 2] 
 [3 0 2 2] 
 [3 3 4 2] 
 [3 4 4 4] 
 [5 5 6 6] 
 [5 5 6 6] 
 [7 7 7 7] 
 [8 8 8 9] 
 [8 9 9 9]]
```

## Заметки
- Теоретически допускаются дырки и выступы на полях, но работоспособнность на них не провералась. Например:
```
example_area = [
    [1,1,1,0],
    [1,0,1,1],
    [1,1,1,0]
]
```
- В классе есть флаг `is_rotate`. По идее, он регулирует могут ли фигуры вертется, или как задал - так задал. По умолчанию разворот разрешен. Работоспособность запрещения разварота не тестировалась.